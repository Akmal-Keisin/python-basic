# Python Try...Except (Exception Handling)

## The Concept

Errors in Python are called **Exceptions**. If an exception occurs and your code doesn't handle it, the program crashes (terminates).
**Exception Handling** is the process of catching these errors so your program can continue running or fail gracefully (e.g., show a user-friendly error message instead of a scary traceback).

## Basic Syntax

The core structure consists of `try` and `except`.

### The Simple Block

```python
try:
    # Code that might crash
    numerator = 10
    denominator = 0
    result = numerator / denominator
    print(result) # This line is skipped if error occurs above
except:
    # Code that runs ONLY if an error occurs
    print("Oops! You cannot divide by zero.")

# Output: Oops! You cannot divide by zero.
```

### Getting Error Details (`as e`)

You can access the actual error message generated by Python using the `as` keyword.

```python
try:
    number = int("Hello World")
except ValueError as e:
    print(f"A specific error occurred: {e}")

# Output: A specific error occurred: invalid literal for int() with base 10: 'Hello World'
```

## Catching Specific Exceptions (Crucial)

**Golden Rule:** Never use a "bare except" (an `except:` with nothing after it) unless you absolutely have to. It catches *everything*, including you trying to exit the program with Ctrl+C.

Always catch the **specific** error you expect.

### Specific Blocks

```python
try:
    file = open("non_existent_file.txt")
    data = 10 / 0
except FileNotFoundError:
    print("Error: File not found.")
except ZeroDivisionError:
    print("Error: You divided by zero.")
```

### Grouping Exceptions (The Tuple Method)

If you want to handle multiple errors with the *same* logic:

```python
try:
    # Complex logic
    result = 10 / 0
except (ZeroDivisionError, ValueError, TypeError) as e:
    print("Something went wrong with the math or types.")
```

## The Complete Workflow (`else` & `finally`)

Python has two powerful extra blocks: `else` and `finally`.

### The `else` Block

Runs **only if NO exception occurred**.
*Why use it?* It allows you to keep your `try` block small. Only put the line that *might* crash in `try`. Put the code that relies on that success in `else`.

### The `finally` Block

Runs **ALWAYS**, regardless of whether an error happened or not.
*Why use it?* Cleanup actions (Closing database connections, closing files, releasing resources).

### The Full Structure:

```python
def read_file_content(filename):
    try:
        f = open(filename, 'r')
        # Only open logic here
    except FileNotFoundError:
        print("File doesn't exist!")
    else:
        # Read logic here (only runs if open succeeded)
        print(f.read())
        print("Read successful.")
    finally:
        # Cleanup logic here (always runs)
        print("Closing operations...")
        try:
            f.close()
        except:
            pass # Handle case where f wasn't defined
```

-----

## Raising Exceptions (Manual Errors)

Sometimes *you* want to trigger an error. For example, if a user inputs a valid number (integer) but it doesn't meet your business logic (e.g., negative age).

Use the `raise` keyword.

```python
def set_age(age):
    if age < 0:
        raise ValueError("Age cannot be negative!")
    print(f"Age set to {age}")

try:
    set_age(-5)
except ValueError as err:
    print(err) 
    # Output: Age cannot be negative!
```

-----

## Advanced Concepts

### Custom Exceptions

In large projects, built-in errors (`ValueError`) aren't descriptive enough. You create your own by inheriting from the `Exception` class.

```python
class InsufficientFundsError(Exception):
    """Raised when withdrawal is greater than balance"""
    pass

def withdraw(amount, balance):
    if amount > balance:
        raise InsufficientFundsError(f"Cannot withdraw {amount}. Balance is {balance}")

try:
    withdraw(100, 50)
except InsufficientFundsError as e:
    print(f"Transaction Denied: {e}")
```

### Exception Chaining (`raise ... from`)

Useful when you catch an error but want to raise a *different* error while keeping the history of the original one (the stack trace).

```python
try:
    # Database logic
    1 / 0
except ZeroDivisionError as original_error:
    # Wrap it in a generic database error
    raise RuntimeError("Database connection failed") from original_error
```

-----

## Python Best Practices (Professional Style)

### The EAFP Principle

Python coding style follows the **EAFP** philosophy: **"It's Easier to Ask for Forgiveness than Permission."**

  * **LBYL (Look Before You Leap) - Common in C/Java:**

    ```python
    # Check if file exists, then delete
    import os
    if os.path.exists("file.txt"):
        os.remove("file.txt")
    ```

    *Problem:* In the millisecond between checking and removing, another program might delete the file, causing a crash.

  * **EAFP (Python Style):**

    ```python
    # Just try to delete it, catch error if it fails
    import os
    try:
        os.remove("file.txt")
    except FileNotFoundError:
        pass # We don't care if it was already gone
    ```

    *Benefit:* Faster (no checking overhead) and atomic (avoids race conditions).

### Avoid "Exception Swallowing"

Do not simply `pass` without logging.

```python
# BAD
try:
    complex_logic()
except Exception:
    pass  # Now you have no idea why your app is failing silently.

# GOOD
import logging
try:
    complex_logic()
except Exception as e:
    logging.error(f"Logic failed: {e}")
    # Ideally, re-raise it if you can't handle it
```

### Keep `try` Blocks Small

Don't put 50 lines of code inside a `try`. Put only the line that might crash. This prevents you from accidentally catching an error you didn't intend to handle.